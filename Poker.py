import randomimport pandas as pdclass Poker:###产生一副乱序牌堆，每次运行draw()抽取牌堆顶端的牌 ***完善的整体***    def __init__(self):        suits = ["♥", "♠", "♣", "♦"]        points = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']        box = []        cards = []        n = 51        for i in suits:            for j in points:                k = i + j                box.append(k)        while n >= 0:            index = random.randint(0, n)            cards.append(box[index])            box.pop(index)            n -= 1        self.c = cards          self.t = -1        print(self.c)        def draw(self):        self.t += 1        return self.c[self.t]P = Poker()        class ComputerPlayer:###电脑玩家，下注策略有待优化    def __init__(self):        self.name = None###名字        self.alive = True###是否存活(未输光)        self.fold = False###是否盖牌        self.allin = False###是否allin        self.chips = 500###筹码数量        self.bet = 0###一轮中总共下注数量        self.seat = None###座位        self.hands = []###手牌        self.score = 0###牌型得分        self.type = None###牌型        self.blind = True###是否处于下盲注阶段            def w_init(self):###新一轮游戏初始化        self.fold = False        self.allin = False        self.bet = 0        self.hands = []        self.score = 0        self.type = None        self.blind = True        if self.chips == 0:            self.alive = 0                def r_hands(self):###抽取手牌        self.hands = [P.draw(), P.draw()]    def w_st(self, s_t):###得知自己的牌型和牌型得分        self.score = s_t[0]        self.type = s_t[1]                            def decision(self, stage, pod, highbet, board):###决策函数，有待优化        bet = 0###本环节已经下注的筹码        needed = highbet - self.bet###还需要下注多少才能不盖牌                if self.alive:            if (not self.fold) and (not self.allin):                                if stage == 'preflop':###翻牌之前                    if self.blind:###SB和BB下盲注                        if self.seat == 'SB':                            bet = 1                        elif self.seat == 'BB':                            bet = 2                        else:                            r = random.random()                            if r < 0.15:                                self.fold = True                            elif 0.15 <= r <= 0.9:                                bet = needed                            else:                                bet = needed + self.chips * 0.2                        self.blind = False                    else:                        r = random.random()                        if r < 0.2:                            self.fold = True                        elif 0.2 <= r <= 0.9:                            bet = needed                        else:                            bet = needed + self.chips * 0.2                  elif stage == 'flop': ###翻牌环节，随机盖牌，跟注，或加注                    r = random.random()                    if r < 0.2:                        self.fold = True                    elif 0.2 <= r <= 0.8:                        bet = needed                    else:                        bet = needed + self.chips * 0.3                                            elif stage == 'turn': ###转牌环节，同上                    r = random.random()                    if r < 0.2:                        self.fold = True                    elif 0.15 <= r <= 0.7:                        bet = needed                    else:                        bet = needed + self.chips * 0.4                                            elif stage == 'river': ###河牌环节，同上                    r = random.random()                    if r < 0.2:                        self.fold = True                    elif 0.1 <= r <= 0.6:                        bet = needed                    else:                        bet = needed + self.chips * 0.7                                        bet = round(bet) ###决策的结果下注数额大于自己的筹码则all in，将筹码投入奖池                if bet > self.chips:                    bet = self.chips                    self.allin = True                self.chips -= bet                self.bet += bet                            return [bet, self.bet, self.allin] ###返回[本环节下注数量，本轮游戏下注总量，是否all in]                                            class You: ###人类玩家交互端口，我还没写    def __init__(self):        self.alive = True        self.fold = False        self.allin = False        self.chips = 500        self.seat = None        self.hands = []        self.score = 0        self.type = None            def r_hands(self):        self.hands = [P.draw(), P.draw()]                def w_st(self, s_t):        self.score = s_t[0]        self.type = s_t[1]    def decision():        pass                                                   class Dealer: ###荷官 ***几乎完善***    def __init__(self, n):        self.players = [] ###玩家清单        HP = You()        P1 = ComputerPlayer()        P2 = ComputerPlayer()        P3 = ComputerPlayer()        P4 = ComputerPlayer()        P5 = ComputerPlayer()        P6 = ComputerPlayer()        P7 = ComputerPlayer()        P8 = ComputerPlayer()        P9 = ComputerPlayer()        P10 = ComputerPlayer()        l_P = [P1, P2, P3, P4, P5, P6, P7, P8, P9, P10]        name = ['You', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10']        for i in range(n):            l_P[i].name = name[i]            self.players.append(l_P[i])        self.pod = 0 ###奖池中的筹码数量        self.board = [] ###公共牌        self.stage = 'begin' ###当前游戏阶段        self.order = [] ###玩家决策顺序        self.highbet = 0 ###当前阶段的最高下注        self.done = 0 ###当前阶段完成决策的人数                        def w_init(self): ###新一轮游戏初始化        self.pod = 0        self.board = []        self.highbet = 0        self.done = 0                            def left(self): ###返回当前存活玩家名单        l = []        for i in range(len(self.players)):            if self.players[i].alive:                l.append(i)        return l                def notfold(self): ###返回未盖牌的玩家序号list        l = []        for i in range(len(self.players)):            if not self.players[i].fold:                l.append(i)        return l                    def end(self): ###结束游戏，人类玩家未取得第一        rank = len(self.left()) + 1        print('You are #' + str(rank))        print('Congratulations!')                            def win(self): ###结束游戏，人类玩家取得第一        print('Winner Winner')        print('Chicken Dinner!')                            def judge(self, hands): ###裁判函数，需要知道谁的牌型更大时调用，返回[可能组成的最大牌型得分，牌型名称] ***完善的整体***        score = 0        flush = False        straight = False        Types = None        l = self.board + hands        suits = [i[0] for i in l]        points = [i[1] for i in l]                H = []        S = []        C = []        D = []        P_1 = []        P_2 = []        P_3 = []        P_4 = []        P_5 = []        P_6 = []        P_7 = []        P_8 = []        P_9 = []        P_10 = []        P_11 = []        P_12 = []        P_13 = []        P_14 = []                for i in range(len(suits)):            if suits[i] == "♥":                H.append(i)            if suits[i] == "♠":                S.append(i)            if suits[i] == "♣":                C.append(i)            if suits[i] == "♦":                D.append(i)        for i in range(len(points)):            if points[i] == 'A':                P_1.append(i)                P_14.append(i)            if points[i] == '2':                P_2.append(i)            if points[i] == '3':                P_3.append(i)            if points[i] == '4':                P_4.append(i)            if points[i] == '5':                P_5.append(i)            if points[i] == '6':                P_6.append(i)            if points[i] == '7':                P_7.append(i)            if points[i] == '8':                P_8.append(i)            if points[i] == '9':                P_9.append(i)            if points[i] == '10':                P_10.append(i)            if points[i] == 'J':                P_11.append(i)            if points[i] == 'Q':                P_12.append(i)            if points[i] == 'K':                P_13.append(i)                    Suits = [H, S, C, D]        Points = [P_1, P_2, P_3, P_4, P_5, P_6, P_7, P_8, P_9, P_10, P_11, P_12, P_13, P_14]                #铁枝        for i in Points:            if len(i) == 4:                score = 7E8                        #葫芦            if score == 0:            for i in range(len(Points)):                if len(Points[i]) == 3:                    for j in range(len(Points)):                        if i != j:                            if len(Points[j]) >= 2:                                score = 6E8 + max([i, j])                                #同花        if score == 0:            h1 = 0            h2 = 0            h3 = 0            h4 = 0            h5 = 0            for i in Suits:                if len(i) > 4:                    nf = i                    for j in range(len(Points)):                        if len(Points[j]) == 3:                            h5 = h4                            h4 = h3                            h3 = j                            h2 = j                            h1 = j                        if len(Points[j]) == 2:                            h5 = h4                            h4 = h3                            h3 = h2                            h2 = j                            h1 = j                        if len(Points[j]) == 2:                            h5 = h4                            h4 = h3                            h3 = h2                            h2 = h1                            h1 = j                    score = 5E8 + 20000*h1 + 2000*h2 + 200*h3 + 20*h4 + h5                    flush = True                        #顺子        if score == 0 or flush:            for i in range(11):                if len(Points[i]) > 0:                    n = 0                    while True:                        n += 1                        if i+n <= 13:                            if len(Points[i+n]) == 0:                                break                        if i+n > 13:                            break                    if n == 5:                        score = 4E8 + i + n                        straight = True                        ns = []                        for j in range(i, i+n):                            ns.append(Points[j])                                        #三条        if score == 0:            h1 = 0            h2 = 0            for i in range(len(Points)):                if len(Points[i]) == 3:                    for j in range(len(Points)):                        if len(Points[j]) == 1:                            h2 = h1                            h1 = j                            score = 3E8 + h1*20 + h2                #两对        if score == 0:            n = 0            p1 = 0            p2 = 0            for i in range(len(Points)):                if len(Points[i]) == 2:                    n += 1                    p2 = p1                    p1 = i            if n >= 2:                for j in range(len(Points)):                    if len(Points[j]) > 0:                        score = 2E8 + p1*200 + p2*20 + j                                #一对        if score == 0:            h1 = 0            h2 = 0            h3 = 0            for i in range(len(Points)):                if len(Points[i]) == 2:                    for j in range(len(Points)):                        if len(Points[j]) > 0:                            h3 = h2                            h2 = h1                            h1 = j                    score = 1E8 + i*2000 + h1*200 + h2*20 + h1                                #高张        if score == 0:            h1 = 0            h2 = 0            h3 = 0            h4 = 0            h5 = 0            for i in range(len(Points)):                if len(Points[i]) == 1:                    h5 = h4                    h4 = h3                    h3 = h2                    h2 = h1                    h1 = i            score = h1*20000 + h2*2000 + h3*200 + h4*20 + h5                    #同花顺        if flush and straight:            s_f = True            for i in ns:                if len(i) == 1:                    if i[0] not in nf:                        s_f = False                else:                    n = 0                    for j in i:                        if j not in nf:                            n += 1                    if n == len(i):                        s_f = False            if s_f:                for i in range(11):                    if len(Points[i]) > 0:                        n = 0                        while True:                            n += 1                            if i+n <= 13:                                if len(Points[i+n]) == 0:                                    break                            if i+n > 13:                                break                        if n == 5:                            score = 8E8 + i + n                if score < 1E8:            Types = 'High Card'        if score >= 1E8 and score < 2E8:            Types = 'One Pair'        if score >= 2E8 and score < 3E8:            Types = 'Two Pair'        if score >= 3E8 and score < 4E8:            Types = 'Three of a Kind'        if score >= 4E8 and score < 5E8:            Types = 'Straight'        if score >= 5E8 and score < 6E8:            Types = 'Flush'        if score >= 6E8 and score < 7E8:            Types = 'Full House'        if score >= 7E8 and score < 8E8:            Types = 'Four of a Kind'        if score >= 8E8:            Types = 'Straight Flush'        if score == 8E8 + 14:            Types = 'Royal Straight Flush'                return [score, Types]        def settle(self): ###清算函数，不再有玩家做出动作，需要分配奖池中的筹码时调用 ***完善的整体***        if len(self.notfold()) == 1:            self.players[self.notfold()[0]].chips += self.pod            self.pod = 0             else:            s = [] ###得分list（和玩家顺序相同）            a = 0 ###allin人数            e = 0 ###平分奖池人数            for i in self.players:                if i.allin:                    a += 1            for i in range(len(self.players)): ###不盖牌的记录牌型得分，盖牌的计作0                if not self.players[i].fold:                    s_t = self.judge(self.players[i].hands) ###[分数，牌型]                    self.players[i].w_st(s_t)                    s.append(s_t[0])                else:                    s.append(0)            while a > 0: ###优先结算所有allin玩家                for i in range(len(self.players)):                    if self.players[i].allin: ###如果allin玩家是最高分，获得投出筹码的2倍                        if s[i] < max(s):                            a -= 1                        else:                            if self.pod >= self.players[i].bet * 2:                                self.players[i].chips = self.players[i].bet * 2                                self.pod -= self.players[i].chips                                s[i] = 0                                a -= 1                            else:                                self.players[i].chips += self.pod                                self.pod = 0                                a = 0                                    if self.pod > 0:###如果奖池未归零，全部分给未allin的最高分玩家                           for i in self.players:                    if i.score == max(s):                        e += 1                                        bonus = round(self.pod / e)                for i in self.players:                    if i.score == max(s):                        i.chips += bonus                        i.score = 0                self.pod = 0                                self.stage = 'begin'                      def begin(self): ###开局流程 ***完善的整体***        P.__init__() ###初始化牌堆，初始化玩家参数，初始化自身参数        self.w_init()        for i in self.players:            i.w_init()                if not self.players[0].alive: ###如果人类玩家死亡，立即触发非第一名结局            self.end()            self.stage = None                    else: ###如果只剩人类玩家存活，立即触发第一名结局            if len(self.left()) == 1:                self.players = [self.players[0]]                self.win()                self.stage = None                            else: ###如果游戏未结束，将所有死亡玩家移出名单，大小盲轮换                l = self.left()                s = []                r = True                for i in range(len(self.players)):                    if self.players[i].seat == 'SB':                        s.append(i)                t = []                for i in l:                    t.append(self.players[i])                if len(s) == 0:                    self.players = t                    self.players[0].seat = 'S'                    self.players[1].seat = 'B'                else:                    for i in l:                        if i > s[0]:                            self.players[i].seat = 'S'                            r = False                            break                    if r:                        self.players[l[0]].seat = 'S'                    self.players = t                    if self.players[-1].seat == 'S':                        self.players[0].seat = 'B'                    else:                        for i in range(len(self.players)):                            if self.players[i].seat == 'S':                                self.players[i+1].seat = 'B'                                break                for i in self.players:                    if i.seat != 'S' and i.seat != 'B':                        i.seat = None                    elif i.seat == 'S':                        i.seat = 'SB'                    elif i.seat == 'B':                        i.seat = 'BB'                for i in range(len(self.players)):                    if self.players[i].seat == 'SB':                        n = i                        self.order.clear()                        while len(self.order) < len(self.players):                            self.order.append(n)                            if n == len(self.players) - 1:                                n = 0                            else:                                n += 1                self.stage = 'preflop'                    def preflop(self): ###翻牌前流程，给每个玩家抽取手牌，让玩家依次做出决策 ***完善的整体***        for i in self.players:            i.r_hands()        self.done = 0        while self.done < len(self.players) and len(self.notfold()) > 1:            for i in self.order:                result = self.players[i].decision('preflop', self.pod, self.highbet, self.board)                self.pod += result[0]                if result[1] > self.highbet:                    self.highbet = result[1]                    self.done = 0                self.done += 1        if len(self.notfold()) == 1: ###如果只剩一个人未盖牌，直接清算            self.settle()        self.stage = 'flop'                        def flop(self): ###翻盘流程，抽取3张公共牌，让玩家依次做出决策 ***完善的整体***        self.board = [P.draw(), P.draw(), P.draw()]        self.done = 0        while self.done < len(self.players) and len(self.notfold()) > 1:            for i in self.order:                result = self.players[i].decision('flop', self.pod, self.highbet, self.board)                self.pod += result[0]                if result[1] > self.highbet:                    self.highbet = result[1]                    self.done = 0                self.done += 1        if len(self.notfold()) == 1:            self.settle()        self.stage = 'turn'                def turn(self): ###转牌流程，再抽取1张公共牌，让玩家依次决策 ***完善的整体***        self.done = 0        self.board.append(P.draw())        while self.done < len(self.players) and len(self.notfold()) > 1:            for i in self.order:                result = self.players[i].decision('turn', self.pod, self.highbet, self.board)                self.pod += result[0]                if result[1] > self.highbet:                    self.highbet = result[1]                    self.done = 0                self.done += 1        if len(self.notfold()) == 1:             self.settle()        self.stage = 'river'                      def river(self): ###河牌流程，同上 ***完善的整体***        self.done = 0        self.board.append(P.draw())        while self.done < len(self.players) and len(self.notfold()) > 1:            for i in self.order:                result = self.players[i].decision('river', self.pod, self.highbet, self.board)                self.pod += result[0]                if result[1] > self.highbet:                    self.highbet = result[1]                    self.done = 0                self.done += 1        self.settle() ###2名以上玩家比拼到最后，调用清算函数                            def flow(self): ###循环进行游戏环节，直到人类玩家死亡或获胜，将比赛记录保存为csv文件        Round = 0        Index = []        C_L = []        j = 0        for i in self.players:            j += 1            C_L.append('name_' + str(j))            C_L.append('seat_' + str(j))            C_L.append('fold_' + str(j))            C_L.append('all_in_' + str(j))            C_L.append('chips_' + str(j))            C_L.append('bet_' + str(j))            C_L.append('hands_' + str(j))            C_L.append('type_' + str(j))            C_L.append('score_' + str(j))        A = [[], [], [], []]        for i in self.players:            for k in range(9):                A.append([])                   while self.players[0].alive and len(self.players) > 1:            if self.stage == 'begin':                Round += 1                self.begin()            elif self.stage == 'preflop':                self.preflop()            elif self.stage == 'flop':                self.flop()            elif self.stage == 'turn':                self.turn()            elif self.stage == 'river':                self.river()                            Index.append(Round)            A[0].append(self.stage)            A[1].append(self.pod)            A[2].append(self.highbet)            A[3].append(self.board)                        for i in range(len(self.players)):                A[i*9+4].append(self.players[i].name)                A[i*9+5].append(self.players[i].seat)                A[i*9+6].append(self.players[i].fold)                A[i*9+7].append(self.players[i].allin)                A[i*9+8].append(self.players[i].chips)                A[i*9+9].append(self.players[i].bet)                A[i*9+10].append(self.players[i].hands)                A[i*9+11].append(self.players[i].type)                A[i*9+12].append(self.players[i].score)            self.get()        for i in A:                    while len(i) < len(A[0]):                i.append('')                        R = pd.DataFrame({'next_stage': A[0]                          ,'pod': A[1]                          ,'high_bet': A[2]                          ,'board': A[3]                          })        for i in range(len(C_L)):            R[C_L[i]] = A[i+4]        R.index = Index        R.to_csv('Record.csv', encoding="utf_8_sig")    def get(self): ###没啥大用，为了让你看见程序在运行        print('#######################')        print('nextstage:', self.stage)        print('board:', self.board)        print('highbet:', self.highbet)        print('pod:', self.pod)        ALL = 0        for i in self.players:            print(i.name, i.seat, 'F:', i.fold, 'C:', i.chips, i.hands,  i.type, i.score)            ALL += i.chips        print('***', ALL + self.pod, '***')                                       D = Dealer(5) ###让n名玩家开始比赛，目前用电脑玩家代替人类玩家，因此会自动完成所有流程D.flow()